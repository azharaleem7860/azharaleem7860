Absolutely, Azhar. Hereâ€™s a robust and production-ready version of your `AgentFactory` that gracefully handles missing dependencies, malformed manifests, and dynamic class imports. This version is designed for manifest-driven orchestration in your ADK-style multi-agent system.

---

âœ… Updated `AgentFactory` Class

import os
import json
import importlib
from typing import Dict, Any

class AgentFactory:
    def __init__(self, manifest_dir: str):
        self.manifest_dir = manifest_dir
        self.manifests: Dict[str, Dict[str, Any]] = {}
        self.agents: Dict[str, Any] = {}

    def load_manifests(self):
        for filename in os.listdir(self.manifest_dir):
            if filename.endswith(".json"):
                path = os.path.join(self.manifest_dir, filename)
                try:
                    with open(path, "r") as f:
                        manifest = json.load(f)
                        agent_name = manifest.get("agent_name")
                        if not agent_name:
                            print(f"âš ï¸ Skipping manifest {filename}: missing 'agent_name'")
                            continue
                        self.manifests[agent_name] = manifest
                except Exception as e:
                    print(f"âŒ Failed to load manifest {filename}: {e}")

    def instantiate_agents(self):
        for agent_name in self.manifests:
            if agent_name not in self.agents:
                self._instantiate_agent_recursive(agent_name)

    def _instantiate_agent_recursive(self, agent_name: str):
        if agent_name in self.agents:
            return self.agents[agent_name]

        manifest = self.manifests.get(agent_name)
        if not manifest:
            raise ValueError(f"Manifest not found for agent: {agent_name}")

        # Resolve dependencies
        dep_names = manifest.get("dependencies") or []
        if not isinstance(dep_names, list):
            raise TypeError(f"Dependencies for {agent_name} must be a list")

        dependencies = []
        for dep_name in dep_names:
            if dep_name not in self.manifests:
                print(f"âš ï¸ Dependency '{dep_name}' not found for agent '{agent_name}'")
                continue
            dep_instance = self._instantiate_agent_recursive(dep_name)
            dependencies.append(dep_instance)

        # Import and instantiate agent class
        try:
            agent_class = self._import_class(manifest["class_path"])
            agent_instance = agent_class(*dependencies)
            self.agents[agent_name] = agent_instance
            print(f"âœ… Instantiated agent: {agent_name}")
            return agent_instance
        except Exception as e:
            print(f"âŒ Failed to instantiate agent '{agent_name}': {e}")
            return None

    def _import_class(self, class_path: str):
        module_name, class_name = class_path.rsplit(".", 1)
        module = importlib.import_module(module_name)
        return getattr(module, class_name)

    def get_agent(self, agent_name: str):
        return self.agents.get(agent_name)


---

ğŸ§  Key Improvements

â€¢ âœ… Handles missing or malformed `dependencies` field
â€¢ âœ… Recursively instantiates dependencies in correct order
â€¢ âœ… Skips unresolved dependencies with warnings
â€¢ âœ… Validates manifest structure before instantiation
â€¢ âœ… Logs success and failure clearly for debugging


---

Would you like a companion script that validates all manifests before runtimeâ€”checking for missing fields, broken class paths, and unused agents? That would give you full confidence before deployment.
