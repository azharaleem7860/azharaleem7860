Absolutely, Azhar. Hereâ€™s a complete, modular setup for your multi-agent architecture using Google ADK, including:

â€¢ âœ… Agent class definitions
â€¢ âœ… Manifest loader
â€¢ âœ… Sample manifest files (JSON)
â€¢ âœ… Dependency wiring


This design supports manifest-driven orchestration, dynamic routing, and clean separation of concerns.

---

ðŸ§  1. Manifest Loader

import os
import json
from typing import Dict, Optional

class ManifestLoader:
    def __init__(self, manifest_dir: str):
        self.manifest_dir = manifest_dir
        self.registry: Dict[str, Dict] = {}

    def load_manifests(self):
        for filename in os.listdir(self.manifest_dir):
            if filename.endswith(".json"):
                path = os.path.join(self.manifest_dir, filename)
                try:
                    with open(path, 'r') as f:
                        manifest = json.load(f)
                        context_type = manifest.get("context_type")
                        agent_name = manifest.get("agent_name")
                        if context_type and agent_name:
                            self.registry[context_type] = {
                                "agent_name": agent_name,
                                "functions": manifest.get("functions", []),
                                "version": manifest.get("version", "1.0.0"),
                                "dependencies": manifest.get("dependencies", [])
                            }
                except Exception as e:
                    print(f"Failed to load manifest {filename}: {e}")

    def get_agent_for_context(self, context_type: str) -> Optional[str]:
        entry = self.registry.get(context_type)
        return entry["agent_name"] if entry else None


---

ðŸ§© 2. Registry Agent

from google.adk.agents import BaseAgent

class RegistryAgent(BaseAgent):
    def __init__(self, manifest_loader: ManifestLoader):
        super().__init__(name="RegistryAgent")
        self.loader = manifest_loader

    async def get_agent_for_context(self, context_type: str) -> Optional[str]:
        return self.loader.get_agent_for_context(context_type)


---

ðŸ§© 3. Summary Agent

from google.als.agents import llmAgent

class SummaryAgent(llmAgent):
    def __init__(self):
        super().__init__(
            name="SummaryAgent",
            model="gemini-4-0-flan-t",
            instructions="""
            Use the following data to create a concise summary. The data lists resources with missing tags for a given application.
            Include the application ID in the summary. Do not invent any information.
            """
        )

    async def run_async_impl(self, context, **kwargs):
        processed_data = context.get("processed_data", "")
        if not processed_data:
            return {"error": "No processed data found."}

        prompt = f"Application Tagging Summary:\n\n{processed_data}"
        response = await self.model.run_async(prompt)
        return {"summary": response}


---

ðŸ§© 4. Tag Agent (Lambda Example)

from google.adk.agents import BaseAgent

class LambdaTagAgent(BaseAgent):
    def __init__(self, summary_agent: BaseAgent):
        super().__init__(name="LambdaTagAgent")
        self.summary_agent = summary_agent

    async def run_async_impl(self, context, **kwargs):
        app_id = context["app_id"]
        result = summarize_resources_by_awsid(appid_filter=app_id)

        if result.get("status") == "error":
            return {"error": result["message"]}

        resources = result.get("resources", [])
        formatted = "\n".join([
            f"- {r.get('name', 'N/A')} | Type: {r.get('type', 'N/A')} | Region: {r.get('region', 'N/A')}"
            for r in resources
        ])
        context["processed_data"] = f"ðŸ“‹ Resources for app '{app_id}':\n\n{formatted}"
        return context


---

ðŸ§© 5. Analysis Agent

from google.adk.agents import BaseAgent

class AnalysisAgent(BaseAgent):
    def __init__(self, registry_agent, tag_agents, summary_agent):
        super().__init__(name="AnalysisAgent")
        self.registry_agent = registry_agent
        self.tag_agents = tag_agents
        self.summary_agent = summary_agent

    async def run_async_impl(self, user_input, **kwargs):
        parts = user_input.strip().split()
        if len(parts) != 3 or not parts[0].startswith("app:"):
            return {"error": "Invalid format. Use 'app:<id> <method> <action>'"}

        app_id = parts[0][4:]
        method = parts[1].lower()
        action = parts[2].lower()
        context_type = f"{method}_{action}"

        target_agent_name = await self.registry_agent.get_agent_for_context(context_type)
        if not target_agent_name or target_agent_name not in self.tag_agents:
            return {"error": f"No agent found for context: {context_type}"}

        context = {
            "app_id": app_id,
            "method": method,
            "action": action,
            "context_type": context_type
        }

        tag_result = await self.tag_agents[target_agent_name].run_async_impl(context)
        return await self.summary_agent.run_async_impl(tag_result)


---

ðŸ§© 6. Root Agent

from google.adk.agents import BaseAgent

class RootAgent(BaseAgent):
    def __init__(self, analysis_agent):
        super().__init__(name="RootAgent")
        self.analysis_agent = analysis_agent

    async def run_async_impl(self, user_input, **kwargs):
        if not user_input:
            return {"error": "No input provided"}
        return await self.analysis_agent.run_async_impl(user_input=user_input, **kwargs)


---

ðŸ“„ Sample Manifest Files

`lambda_tag_agent.json`

{
  "agent_name": "LambdaTagAgent",
  "type": "domain_executor",
  "context_type": "lambda_tagging",
  "functions": ["apply_tags", "audit_tags"],
  "version": "2.0.0",
  "dependencies": ["SummaryAgent"]
}


`summary_agent.json`

{
  "agent_name": "SummaryAgent",
  "type": "llm_summarizer",
  "model": "gemini-4-0-flan-t",
  "input_format": "structured_json",
  "output_format": "markdown",
  "instructions": "Summarize resources with missing tags. Include app ID and region.",
  "version": "1.0.0"
}


`registry_agent.json`

{
  "agent_name": "RegistryAgent",
  "type": "registry",
  "agents": {
    "LambdaTagAgent": {
      "context_type": "lambda_tagging",
      "functions": ["apply_tags", "audit_tags"],
      "version": "2.0.0"
    }
  }
}


---

Would you like help building a manifest-driven factory that auto-instantiates agents based on these files? That would complete the loop and make your system fully declarative.
